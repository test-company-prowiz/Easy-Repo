# Github-Repository-Management/src/main/java/com/Barsat/Github/Repository/Management/Config/Jwt/JwtUtils.java

### Overview
This file defines a Spring service class, `JwtUtils`, responsible for the lifecycle management of JSON Web Tokens (JWTs). It handles the generation, parsing, validation, and extraction of claims from JWTs within the application, primarily for authentication and authorization purposes.

### Architecture & Role
`JwtUtils` operates at the security configuration layer of the application. Annotated with `@Service`, it is managed by the Spring IoC container and designed to be injected into other components that require JWT capabilities. Its primary role is to provide utility functions for creating and verifying JWTs, integrating with Spring Security's `UserDetails` for token validation.

### Key Components
*   **`JwtUtils` class**: A Spring service that encapsulates all JWT-related logic.
*   **`secretKey` field**: A private string field that stores the Base64 encoded HmacSHA256 secret key used for signing and verifying JWTs. This key is generated dynamically upon the service's instantiation.
*   **`generateToken(String username)`**: Creates a new JWT, setting the subject, issue date, and a fixed 30-hour expiration.
*   **`extractUsername(String token)`**: Parses a given JWT to retrieve the subject claim (username).
*   **`validateToken(String token, UserDetails userDetails)`**: Verifies a JWT by checking its signature, ensuring it's not expired, and confirming the extracted username matches the provided `UserDetails`.
*   **`extractAllClaims(String token)`**: A private helper method that parses and verifies the signature of a token, returning all its claims.
*   **`getMykey()`**: A private helper method that decodes the stored `secretKey` into a `SecretKey` object suitable for JWT signing and verification.

### Execution Flow / Behavior
1.  **Initialization**: When the `JwtUtils` bean is instantiated by the Spring container, its constructor executes. This process involves generating a new HmacSHA256 secret key using `KeyGenerator`, encoding it to Base64, and storing it in the `secretKey` instance variable.
2.  **Token Generation**: When `generateToken(username)` is called, a JWT is constructed. It includes the provided `username` as the subject, the current timestamp as the issuance time, and an expiration time set 30 hours from the current moment. The token is then signed using the dynamically generated `secretKey` and returned as a compact string.
3.  **Token Validation**: When `validateToken(token, userDetails)` is invoked, the method first extracts the username from the provided `token`. It then verifies that this extracted username matches the username from the `userDetails` object and simultaneously checks if the token has expired. Both conditions must be true for the token to be considered valid.
4.  **Claim Extraction**: Methods like `extractUsername` and `extractExpiration` internally use `extractAllClaims` to parse the token and verify its signature with the `secretKey`. Once validated, they apply a claim resolver function to extract the specific claim.

### Dependencies
*   **`io.jsonwebtoken` (JJWT)**: An external library providing the core functionality for creating, parsing, and signing JWTs (`Jwts`, `Claims`, `Decoders`, `Keys`).
*   **`org.springframework.security.core.userdetails.UserDetails`**: An interface from Spring Security used to represent user details, enabling integration with the application's authentication system during token validation.
*   **`org.springframework.stereotype.Service`**: A Spring Framework annotation indicating that this class is a service component, eligible for auto-detection and dependency injection.
*   **`javax.crypto.KeyGenerator`**: Standard Java API for generating cryptographic keys.
*   **`java.security.NoSuchAlgorithmException`**: Standard Java exception for cases where a requested cryptographic algorithm is not available.

### Design Notes
*   **Runtime Secret Key Generation**: The `secretKey` is generated programmatically at application startup. This simplifies deployment as no external key configuration is immediately required, but it means the key will change every time the application restarts, invalidating all previously issued tokens. For multi-instance deployments or persistent sessions across restarts, a more robust key management strategy (e.g., external configuration, key vault, or static key) would be necessary.
*   **Fixed Token Expiration**: All generated tokens have a fixed expiration time of 30 hours. There is no configurable option to vary this duration based on different use cases or user roles.
*   **Basic Claim Set**: The tokens generated by this utility only include `subject`, `issuedAt`, and `expiration` claims. Other common claims like `issuer` or `audience` are not added, which might be a consideration for more complex microservice architectures or multi-party authentication scenarios.

### Diagram (Optional)
None significant.